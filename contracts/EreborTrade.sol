pragma solidity ^0.5.2;

import "./ERC20/tokens/RNTInterface.sol";
import "./Elemmire.sol";
import "./ERC721/tokens/erc721.sol";

contract EreborTrade {
// public variables
	using SafeMath for uint256;
        address[3] public validators;  // for now, managers are also validators
	address[3] public managers;
	address public RNTAddr;
	address public ELEMAddr;
	uint public sidechainblockNo;  // the side-chain number pace controled by validators
        bool public paused = true;  // manager need to make sure there are RNTAddr and ELEMAddr, then unpause
	
// side-block merkle root and tree DB
	struct tradeStat {
		bytes32 merkleRoot;
		string ipfsAddr;
		uint ETHBlockNo;
	}

	mapping (uint => tradeStat) merkleDB; // side-block No. => tradeStat
	
// finalized deal records
	struct dealRecord { // after successful buyer settlement call, record and finalize the trade here
		uint dealMade; 		// deal (TH) included in merkle tree of side-block No.
		uint ETHBlockNo;	// ETH block number when deal is finalized
		bytes32 SellOrder;	// "S" hash
	}

	mapping (bytes32 => dealRecord) settleDB; // "TH" (TradeHash) => dealRecord

// modifier	
	modifier managerOnly() {
	        require(msg.sender != address(0));
		require(msg.sender == managers[0] || msg.sender == managers[1] || msg.sender == managers[2]);
		_;
	}

	modifier validatorOnly() {
	        require(msg.sender != address(0));
		require(msg.sender == validators[0] || msg.sender == validators[1] || msg.sender == validators[2]);
	        _;
        }

        modifier whenNotPaused() {
                require(!paused);
                _;
        }

        modifier whenPaused {
                require(paused);
                _;
        }

// constructor
	constructor(address _RNTAddr, address _ELEMAddr) public {
		managers = [0xB440ea2780614b3c6a00e512f432785E7dfAFA3E,
                    	    0x4AD56641C569C91C64C28a904cda50AE5326Da41,
			    0x362ea687b8a372a0235466a097e578d55491d37f];
		validators = [0xB440ea2780614b3c6a00e512f432785E7dfAFA3E,
                    	      0x4AD56641C569C91C64C28a904cda50AE5326Da41,
			      0x362ea687b8a372a0235466a097e578d55491d37f];
		RNTAddr = _RNTAddr;
		ELEMAddr = _ELEMAddr;
		sidechainblockNo = 0;
	}

// settle function call with merkle proof:
//
// TH is generated by combining an active "S" (order) from seller and an matching "B" from buyer.
//
// RLPx Fields of S (new order): {sellerAddress, time-to-live, NFTokenId, RNTAmount, v,r,s}
// RLPx Fields of S (update order): {sellerAddress, time-to-live, NFTokenId, RNTAmount, v,r,s}
// RLPx Fields of S (replace expired deal): {sellerAddress, time-to-live, NFTokenId, RNTAmount, Stale: { TradeDealMerkleOrigin, TradeHash }, v,r,s}
// RLPx Fields of B (never appears in merkle tree directly): {buyerAddress, SellOrderHash, v',r',s'}
// RLPx Fields of TH (S + B): {deal-time-to-live: 11, sellerAddress, buyerAddress, SellOrderHash, NFTTokenId, RNTAmount, v',r',s'}
//
// The above data format implies:
//  - All active Sell orders will keep being re-inserted into new merkle tree by validators
//  - TH will only be included once into a side-block right after the orders are matched.
//  - TH will actually be put together by validator using the S + B pair. The signature included is the one from B
//  - Seller can update his own order without root-chain action
//  - Once expired, Sell orders will be discarded by validator by not including it into next merkle tree
//  - both buyer and seller will have to approve this contract to transfer their specific tokens, 
//    or their side chain orders will be ignored by validators
//  - All Sell orders has to have at least one side-block confirmation before becoming purchasable by buyers
//  - Buyer can only purchase Sell orders that are included the last known (lastest) commited merkle tree.
//  - When validators receive order update request from seller, even while not yet committed onto side-block, 
//    validator can prevent that sell order to be filled during the rest of side-block-time. 
//  - currently, sell order time-to-live is between 10-100 ETH blocks, while deal-time-to-live is fixed at 11 ETH blocks
//    both started since their first inclusion in the side-block

        function getTradeHash(
            address sellerAddress,
            address buyerAddress,
            bytes32 SellOrderHash,
            uint NFTTokenId,
            uint RNTAmount
        ) public pure returns (bytes32 _tradeHash){
            _tradeHash = keccak256(abi.encodePacked(sellerAddress, buyerAddress, SellOrderHash, NFTTokenId, RNTAmount));
        }

	function settle(uint TradeDealMerkleOrigin, bytes32 TradeHash, 
			address sellerAddress, bytes32 SellOrderHash,
			uint256 NFTTokenId, uint RNTAmount,
			bytes32[] memory proof, bool[] memory isLeft
		       ) public validatorOnly whenNotPaused returns (bool) {
		require(TradeHash == getTradeHash(sellerAddress, msg.sender, SellOrderHash, NFTTokenId, RNTAmount));
	        require(merkleTreeValidator(proof, isLeft, TradeHash, merkleDB[TradeDealMerkleOrigin].merkleRoot));
	        require(RNTAmount >= 10);  // 10 RNT = 1e-4 ETH which is likely less than gas fee

	        // trasnfer token
	        uint txFee1 = RNTAmount.mul(uint256(1) / uint256(1000));  // per validator
	        settleDB[TradeHash] = dealRecord(sidechainblockNo, block.number, SellOrderHash);
		require(RNTInterface(RNTAddr).transferFrom(msg.sender, sellerAddress, RNTAmount - txFee1*validators.length));
		// unfair: not all validators really contribute to submitMerkleRoot. But it's okay for now.
		require(RNTInterface(RNTAddr).transferFrom(msg.sender, validators[0], txFee1));
		require(RNTInterface(RNTAddr).transferFrom(msg.sender, validators[1], txFee1));
		require(RNTInterface(RNTAddr).transferFrom(msg.sender, validators[2], txFee1));
		ERC721(ELEMAddr).safeTransferFrom(sellerAddress, msg.sender, NFTTokenId);
		return true;
	}

	function submitMerkleRoot(bytes32 _merkleRoot, string memory _ipfsAddr) public validatorOnly whenNotPaused returns (bool){
	        require(sidechainblockNo > 0 && merkleDB[sidechainblockNo-1].ETHBlockNo != block.number);  // avoid duplicate ETHBlockNo
	        sidechainblockNo += 1;
	        merkleDB[sidechainblockNo] = tradeStat(_merkleRoot, _ipfsAddr, block.number);
	        return true;
        }

        function merkleTreeValidator(
            bytes32[] memory proof,
            bool[] memory isLeft,
            bytes32 targetLeaf,
            bytes32 _merkleRoot
        ) public pure returns (bool) {
                require(proof.length < 32);  // 2**32 ~ 4.3e9 leaves!
                require(proof.length == isLeft.length);

                bytes32 targetHash = targetLeaf;
                for (uint256 i = 0; i < proof.length; i++) {
                        bytes32 proofEle = proof[i]; 
                        if (isLeft[i]) {
                                targetHash = keccak256(abi.encodePacked(proofEle, targetHash));
                        } else if (!isLeft[i]) {
                                targetHash = keccak256(abi.encodePacked(targetHash, proofEle));
                        } else {
                                return false;
                        }
                }
                return targetHash == _merkleRoot;
        }

        // upgrade address and validators
        function newValidator(address _newValidator, uint8 _idx) public managerOnly returns (bool){
                require(_newValidator != address(0));
                require(_idx >= 0 && _idx < 3);
                validators[_idx] = _newValidator;
                return true;
        }

	function setRNTAddr(address _newRNTAddr) external managerOnly returns (bool){
                RNTAddr = _newRNTAddr;
                return true;
        }

	function setELEMAddr(address _newELEMAddr) external managerOnly returns (bool){
                ELEMAddr = _newELEMAddr;
                return true;
        }

        function pause() external managerOnly whenNotPaused {
                paused = true;
        }

        function unpause() public managerOnly whenPaused {
                paused = false;
        }
}
