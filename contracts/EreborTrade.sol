pragma solidity ^0.5.2;

import "./ERC20/tokens/RNTInterface.sol";
import "./Elemmire.sol";

contract EreborTrade {
// public variables
	address public owner;
	address[3] public managers; // for now, they are the side-chain validator
	
// side-block merkle root and tree DB
	struct tradeStat {
		bytes32 merkleRoot;
		string ipfsAddr;
		uint ETHBlockNo;
	}

	mapping (uint => tradeStat) merkleDB; // side-block No. => tradeStat
	
// finalized deal records
	struct dealRecord { // after successful buyer settlement call, record and finalize the trade here
		uint dealMade; 		// deal (TH) included in merkle tree of side-block No.
		uint ETHBlockNo;	// ETH block number when deal is finalized
		bytes32 SellOrder;	// "S" hash
	}

	mapping (bytes32 => dealRecord) settleDB // "TH" (TradeHash) => dealRecord

// modifier	
	modifier managerOnly() {
		require(msg.sender == managers[0] || msg.sender == manager[1] || msg.sender == manager[2]);
		_;
	}

// constructor
	constructor() public {
		owner = msg.sender;
		managers = [0xB440ea2780614b3c6a00e512f432785E7dfAFA3E,
                    	    0x4AD56641C569C91C64C28a904cda50AE5326Da41,
			    0x362ea687b8a372a0235466a097e578d55491d37f];
	}

// settle function call with merkle proof:
//
// TH is generated by combining an active "S" (order) from seller and an matching "B" from buyer.
//
// RLPx Fields of S (new order): {sellerAddress, time-to-live, NFTokenId, RNTAmount, v,r,s}
// RLPx Fields of S (update order): {sellerAddress, time-to-live, NFTokenId, RNTAmount, v,r,s}
// RLPx Fields of S (replace expired deal): {sellerAddress, time-to-live, NFTokenId, RNTAmount, Stale: { TradeDealMerkleOrigin, TradeHash }, v,r,s}
// RLPx Fields of B (never appears in merkle tree directly): {buyerAddress, SellOrderHash, v',r',s'}
// RLPx Fields of TH (S + B): {deal-time-to-live: 11, sellerAddress, buyerAddress, SellOrderHash, NFTTokenId, RNTAmount, v',r',s'}
//
// The above data format implies:
//  - All active Sell orders will keep being re-inserted into new merkle tree by validators
//  - TH will only be included once into a side-block right after the orders are matched.
//  - TH will actually be put together by validator using the S + B pair. The signature included is the one from B
//  - Seller can update his own order without root-chain action
//  - Once expired, Sell orders will be discarded by validator by not including it into next merkle tree
//  - both buyer and seller will have to approve this contract to transfer their specific tokens, 
//    or their side chain orders will be ignored by validators
//  - All Sell orders has to have at least one side-block confirmation before becoming purchasable by buyers
//  - Buyer can only purchase Sell orders that are included the last known (lastest) commited merkle tree.
//  - When validators receive order update request from seller, even while not yet committed onto side-block, 
//    validator can prevent that sell order to be filled during the rest of side-block-time. 
//  - currently, sell order time-to-live is between 10-100 ETH blocks, while deal-time-to-live is fixed at 11 ETH blocks
//    both started since their first inclusion in the side-block

	function settle(uint TradeDealMerkleOrigin, bytes32 TradeHash, 
			address sellerAddress, bytes32 SellOrderHash, 
			uint256 NFTTokenId, uint RNTAmount,
			bytes32[] memory proof, bool[] memory isLeft) public returns (bool) 
	{
	}
}
